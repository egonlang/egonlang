searchState.loadedDescShard("egonlang_core", 0, "A statement to assert an expression’s type\nExpression for assigning a value expression to an …\nA statement that declares and/or initalizes a variable or …\nAST nodes contained in the <code>Module</code>\nExpression creating a lexical scope that optionally …\nExpressions\nA statement that evaluates an expression then consumes the …\nExpression for assigning a value expression to an …\nExpression creating a lexical scope that optionally …\nExpression creating an anonymous function\nExpression representing literal values e.g. <code>string</code>, <code>number</code>…\nExpression returning a value based on a condition\nExpression preforming an infix operation\nExpression creating a list of same typed values\nExpression representing literal values e.g. <code>string</code>, <code>number</code>…\nExpression preforming a prefix operation\nExpression creating a range of values\nA tuple containing an expression and it’s span e.g. …\nExpression creating a fixed sized collection of mixed …\nExpression representing a type\nExpression creating an anonymous function\nA statement declaring a function\nExpression representing an identifier\nExpression returning a value based on a condition\nExpression preforming an infix operation\nExpression creating a list of same typed values\nExpression representing literal values e.g. <code>string</code>, <code>number</code>…\nA collection of <code>Stmt</code> representing an Egon code file.\nExpression preforming a prefix operation\nExpression creating a range of values\nA statement to return a value from a function\nA statement (e.g. that does not produce a value)\nA statement to assert an expression’s type\nA statement that declares and/or initalizes a variable or …\nA statement that evaluates an expression then consumes the …\nA statement declaring a function\nA statement to return a value from a function\nA tuple containing a statement and it’s span e.g. (stmt, …\nA statement that declares a type alias\nExpression creating a fixed sized collection of mixed …\nExpression representing a type\nA statement that declares a type alias\nValue representing a type\nExpression returning no value\nCreate a <code>bool</code> type instance\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>function</code> type instance\nGet AST nodes by span index\nCreate an <code>identifier</code> type instance\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this a bool type?\nIs this a builtin type?\nIs this a function type?\nIs this an identifier type?\nIs this a number type?\nIs this a range type?\nIs this a string type?\nIs this a tuple type?\nIs this a unit type?\nIs this an unknown type?\nIs this an unknown list type?\nCreate a <code>list&lt;T&gt;</code> type instance\nCreate a <code>number</code> type instance\nCreate a <code>range</code> type instance\nCreate a <code>string</code> type instance\nCreate a <code>tuple&lt;T, U...&gt;</code> type instance\nCreate a <code>type</code> type instance\nThe block’s resolved type\nCreate a <code>()</code> type instance\nCreate an <code>unknown</code> type instance\nCreate a <code>list&lt;unknown&gt;</code> type instance\nConverts a <code>String</code> source in to a vector of <code>Token</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn if a string source has a valid EOF\nParse a string source in to an AST <code>Module</code>")
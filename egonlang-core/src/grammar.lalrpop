use lalrpop_util::ParseError;
use crate::errors::EgonErrorS;

use crate::{ast, lexer, span};

grammar<'err>(
    errors: &'err mut Vec<ParseError<usize, lexer::Token, EgonErrorS>>
);

pub Module: ast::Module = <stmts:Spanned<Decl>*> => ast::Module { <> };

Decl = {
    DeclVar,
    DeclTypeAlias,
    DeclFn,
    Stmt,
}

DeclFn: ast::Stmt = {
    "fn" <name:identifier> <fn_expr:Spanned<ExprFn>> =>
        ast::Stmt::Fn(Box::new(ast::StmtFn { 
            name: ast::Identifier { name: name.clone() },
            fn_expr
         })),
}

DeclVar: ast::Stmt = <assign:StmtAssign> =>
    ast::Stmt::Assign(<>);

DeclTypeAlias: ast::Stmt = <type_alias:StmtTypeAlias> =>
    ast::Stmt::TypeAlias(<>);

StmtAssign: ast::StmtAssign = {
    "let" <name:identifier> <type_expr:(":" <Spanned<TypeRef>>)?> <value:("=" <ExprS>)?> ";" => ast::StmtAssign {
        identifier: ast::Identifier {
            name,
        },
        type_expr: type_expr.map(|(ty, ty_span)|
            (ast::Expr::Type(ast::ExprType(ty)), ty_span)),
        is_const: false,
        value,
    },
    "const" <name:identifier> <type_expr:(":" <Spanned<TypeRef>>)?> <value:("=" <ExprS>)?> ";" => ast::StmtAssign {
        identifier: ast::Identifier {
            name,
        },
        type_expr: type_expr.map(|(ty, ty_span)|
            (ast::Expr::Type(ast::ExprType(ty)), ty_span)),
        is_const: true,
        value,
    },
}

StmtTypeAlias: ast::StmtTypeAlias = {
    "type" <name:identifier> <value:("=" <Spanned<TypeRef>>)> ";" => ast::StmtTypeAlias {
        alias: ast::Identifier {
            name,
        },
        value,
    },
}

StmtS = Spanned<Stmt>;

// Statements
Stmt: ast::Stmt = {
    <expr:ExprS> ";" =>
        ast::Stmt::Expr(ast::StmtExpr { <> }),
    "assert_type" <value:ExprS> "," <expected_type:Spanned<TypeRef>> ";" => ast::Stmt::AssertType(ast::StmtAssertType { 
        value,
        expected_type: (ast::Expr::Type(ast::ExprType(expected_type.0)), expected_type.1)
     }),
     "return" <value:ExprS> ";" => ast::Stmt::Return(ast::StmtReturn::new(<>)),
    <e:!> => {
        errors.push(e.error);
        ast::Stmt::Error
    },
}

// Expressions
ExprS = Spanned<Expr>;

Expr: ast::Expr = {
    ExprAssign,
    ExprBlock,
    
};

ExprAssign: ast::Expr = {
    <name:identifier> "=" <value:ExprS> =>
        ast::Expr::Assign(Box::new(ast::ExprAssign {
            identifier: ast::Identifier { name },
            value,
        })),
    ExprIf,
}

ExprIf: ast::Expr = {
    // if .. else ..
    "if" <cond:Spanned<ExprLogicOr>> <then:Spanned<ExprBlock>> 
    <else_:("else" <Spanned<ExprBlock>>)?>
    => {
        ast::Expr::If(Box::new(ast::ExprIf { <> }))
    },

    // if .. else if ..
    "if" <cond:Spanned<ExprLogicOr>> <then:Spanned<ExprBlock>> 
    <else_:("else" <Spanned<ExprIf>>)>
    => {
        ast::Expr::If(Box::new(ast::ExprIf { 
            cond,
            then,
            else_: Some(else_)
         }))
    },
    ExprLogicOr
}

ExprLogicOr = ExprInfix<ExprLogicOr, OpLogicOr, ExprLogicAnd>;
OpLogicOr: ast::OpInfix = "or" => ast::OpInfix::LogicOr;

ExprLogicAnd = ExprInfix<ExprLogicAnd, OpLogicAnd, ExprEquality>;
OpLogicAnd: ast::OpInfix = "and" => ast::OpInfix::LogicAnd;

ExprEquality = ExprInfix<ExprEquality, OpEquality, ExprComparison>;
OpEquality: ast::OpInfix = {
    "==" => ast::OpInfix::Equal,
    "!=" => ast::OpInfix::NotEqual,
}

ExprComparison = ExprInfix<ExprComparison, OpComparison, ExprTerm>;
OpComparison: ast::OpInfix = {
    ">" => ast::OpInfix::Greater,
    ">=" => ast::OpInfix::GreaterEqual,
    "<" => ast::OpInfix::Less,
    "<=" => ast::OpInfix::LessEqual,
}

ExprTerm = ExprInfix<ExprTerm, OpTerm, ExprFactor>;
OpTerm: ast::OpInfix = {
    "+" => ast::OpInfix::Add,
    "-" => ast::OpInfix::Subtract,
}

ExprFactor = ExprInfix<ExprFactor, OpFactor, ExprPrefix>;
OpFactor: ast::OpInfix = {
    "*" => ast::OpInfix::Multiply,
    "/" => ast::OpInfix::Divide,
    "%" => ast::OpInfix::Modulus,
}

ExprInfix<Lt, Op, Rt>: ast::Expr = {
    <lt:Spanned<Lt>> <op:Op> <rt:Spanned<Rt>> =>
        ast::Expr::Infix(Box::new(ast::ExprInfix { <> })),
    Rt,
}

ExprPrefix: ast::Expr = {
    <op:OpPrefix> <rt:Spanned<ExprPrefix>> =>
        ast::Expr::Prefix(Box::new(ast::ExprPrefix { <> })),
    ExprSimple
}
OpPrefix: ast::OpPrefix = {
    "-" => ast::OpPrefix::Negate,
    "!" => ast::OpPrefix::Not,
}

ExprSimple: ast::Expr = {
    ExprList,
    
};

ExprList: ast::Expr = {
    "[" <items:Seperated<Spanned<Expr>, ",">> "]" =>
        ast::Expr::List(ast::ExprList {<>}),
        ExprTuple
}

ExprTuple: ast::Expr = {
    "(" <items:SeperatedTrailing<Spanned<Expr>, ",">> ")" => 
        ast::Expr::Tuple(ast::ExprTuple {<>}),
        ExprPrimary,
}

ExprPrimary: ast::Expr = {
    // Literals
    string => ast::Expr::Literal(ast::ExprLiteral::String(<>)),
    number => ast::Expr::Literal(ast::ExprLiteral::Number(<>)),
    "(" ")" => ast::Expr::Unit,
    "true" => ast::Expr::Literal(ast::ExprLiteral::Bool(true)),
    "false" => ast::Expr::Literal(ast::ExprLiteral::Bool(false)),

    // Variables
    ExprIdentifier,

    ExprRange,

    ExprFn,

    // Grouping
    "(" <Expr> ")",

}

ExprIdentifier: ast::Expr = <name:identifier> =>
    ast::Expr::Identifier(ast::ExprIdentifier {
        identifier: ast::Identifier {
            name
        }
    });

#[inline]
ExprRange: ast::Expr = {
    <start:Spanned<number>> ".." <inclusive_end:"="?> <end:Spanned<number>> =>
        ast::Expr::Range(ast::ExprRange {
            start: Some((ast::ExprLiteral::Number(start.0), start.1)),
            end: Some((ast::ExprLiteral::Number(end.0), end.1)),
            inclusive_end: inclusive_end.is_some()
        }),
    <start:Spanned<number>> ".." =>
        ast::Expr::Range(ast::ExprRange {
            start: Some((ast::ExprLiteral::Number(start.0), start.1)),
            end: None,
            inclusive_end: false
        }),
    ".." <inclusive_end:"="?> <end:Spanned<number>> =>
        ast::Expr::Range(ast::ExprRange {
            start: None,
            end: Some((ast::ExprLiteral::Number(end.0), end.1)),
            inclusive_end: inclusive_end.is_some()
        }),
}

ExprBlock: ast::Expr = {
    "{" <stmts:(<Spanned<Decl>>)*> <return_expr:(ExprS)?> "}" =>
    ast::Expr::Block(Box::new(
        ast::ExprBlock {
            stmts,
            return_expr,
            typeref: None
        }
    )),
}

FnParam: (ast::Identifier, ast::TypeRef) = <name:identifier> ":" <typeref:TypeRef> => (ast::Identifier { name }, typeref);

ExprFn: ast::Expr = {
   "(" <params:Seperated<Spanned<FnParam>, ",">> ")" ":" <return_type:Spanned<TypeRef>> "=>" <body:Spanned<ExprBlock>> =>
        ast::Expr::Fn(Box::new(ast::ExprFn { 
            name: None,
            params,
            return_type,
            body,
         })),
    "(" <params:Seperated<Spanned<FnParam>, ",">> ")" ":" <return_type:Spanned<TypeRef>> "=>" <body:Spanned<ExprFn>> =>
        ast::Expr::Fn(Box::new(ast::ExprFn { 
            name: None,
            params,
            return_type,
            body,
         })),
}

/// Utilities

TypeRef: ast::TypeRef = {
    <base:identifier> <args:("<" <Seperated<TypeRef, ",">> ">")?> => {
        ast::TypeRef(base, args.unwrap_or_default())
    },

    "(" ")" => ast::TypeRef::unit()
}

Spanned<T>: span::Spanned<T> = <l:@L> <t:T> <r:@R> =>
    (t, l..r);

SeperatedNoDefault<E, T>: Vec<ast::ExprS> = {
    <first:E> <mut args:(T <E>)+> => {
        args.insert(0, first);
        args
    },
}

#[inline]
Seperated<E, T>: Vec<E> = {
    <first:E> <mut args:(T <E>)*> => {
        args.insert(0, first);
        args
    },
    () => Vec::new(),
}

SeperatedTrailing<E, T>: Vec<ast::ExprS> =
    <first:E> <mut args:(T <E>)*> <trailing_seperator:T> => {
        args.insert(0, first);
        args
    };

extern {
    type Location = usize;
    type Error = EgonErrorS;

    enum lexer::Token {
        "{" => lexer::Token::BraceOpen,
        "}" => lexer::Token::BraceClose,
        "[" => lexer::Token::BracketOpen,
        "]" => lexer::Token::BracketClose,
        "(" => lexer::Token::ParanOpen,
        ")" => lexer::Token::ParanClose,
        ";" => lexer::Token::Semicolon,
        "," => lexer::Token::Comma,
        "=>" => lexer::Token::FatArrow,
        ".." => lexer::Token::DotDot,
        ":" => lexer::Token::Colon,

        "-" => lexer::Token::Minus,
        "+" => lexer::Token::Plus,
        "/" => lexer::Token::Slash,
        "%" => lexer::Token::Modulus,
        "*" => lexer::Token::Asterisk,

        "!" => lexer::Token::Bang,
        "!=" => lexer::Token::BangEqual,
        "=" => lexer::Token::Equal,
        "==" => lexer::Token::EqualEqual,
        ">" => lexer::Token::Greater,
        ">=" => lexer::Token::GreaterEqual,
        "<" => lexer::Token::Less,
        "<=" => lexer::Token::LessEqual,

        // Keywords
        "true" => lexer::Token::True,
        "false" => lexer::Token::False,
        "and" => lexer::Token::And,
        "or" => lexer::Token::Or,
        "if" => lexer::Token::If,
        "else" => lexer::Token::Else,
        "fn" => lexer::Token::Fn,
        "let" => lexer::Token::Let,
        "const" => lexer::Token::Const,
        "type" => lexer::Token::Type,
        "assert_type" => lexer::Token::AssertType,
        "return" => lexer::Token::Return,

        // Literals.
        identifier => lexer::Token::Identifier(<String>),
        string => lexer::Token::String(<String>),
        number => lexer::Token::Number(<f64>),
    }
}

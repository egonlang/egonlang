use lalrpop_util::ParseError;
use crate::errors::ErrorS;

use crate::{ast, lexer, span};

grammar<'err>(
    errors: &'err mut Vec<ParseError<usize, lexer::Token, ErrorS>>
);

pub Module: ast::Module = <stmts:Spanned<Stmt>*> => ast::Module { <> };

StmtS = Spanned<Stmt>;

// Statements
Stmt: ast::Stmt = {
    <expr:ExprS> ";" =>
        ast::Stmt::Expr(ast::StmtExpr { <> }),
    <expr:Spanned<ExprIf>> =>
        ast::Stmt::Expr(ast::StmtExpr { <> }),
    <e:!> => {
        errors.push(e.error);
        ast::Stmt::Error
    },
}

// Expressions
ExprS = Spanned<Expr>;

Expr: ast::Expr = {
    ExprLogicOr,
    ExprAssign
};

ExprIf: ast::Expr = {
    // if .. else ..
    "if" <cond:Spanned<ExprLogicOr>> <then:Spanned<ExprBlock>> 
    <else_:("else" <Spanned<ExprBlock>>)?>
    => {
        ast::Expr::If(Box::new(ast::ExprIf { <> }))
    },

    // if .. else if ..
    "if" <cond:Spanned<ExprLogicOr>> <then:Spanned<ExprBlock>> 
    <else_:("else" <Spanned<ExprIf>>)>
    => {
        ast::Expr::If(Box::new(ast::ExprIf { 
            cond,
            then,
            else_: Some(else_)
         }))
    },
}

ExprAssign: ast::Expr = {
    <name:identifier> "=" <value:ExprS> =>
        ast::Expr::Assign(Box::new(ast::ExprAssign {
            identifier: ast::Identifier { name },
            value,
        })),
    <name:identifier> "=" <value:Spanned<ExprIf>> =>
        ast::Expr::Assign(Box::new(ast::ExprAssign {
            identifier: ast::Identifier { name },
            value,
        }))
}

ExprLogicOr = ExprInfix<ExprLogicOr, OpLogicOr, ExprLogicAnd>;
OpLogicOr: ast::OpInfix = "or" => ast::OpInfix::LogicOr;

ExprLogicAnd = ExprInfix<ExprLogicAnd, OpLogicAnd, ExprEquality>;
OpLogicAnd: ast::OpInfix = "and" => ast::OpInfix::LogicAnd;

ExprEquality = ExprInfix<ExprEquality, OpEquality, ExprComparison>;
OpEquality: ast::OpInfix = {
    "==" => ast::OpInfix::Equal,
    "!=" => ast::OpInfix::NotEqual,
}

ExprComparison = ExprInfix<ExprComparison, OpComparison, ExprTerm>;
OpComparison: ast::OpInfix = {
    ">" => ast::OpInfix::Greater,
    ">=" => ast::OpInfix::GreaterEqual,
    "<" => ast::OpInfix::Less,
    "<=" => ast::OpInfix::LessEqual,
}

ExprTerm = ExprInfix<ExprTerm, OpTerm, ExprFactor>;
OpTerm: ast::OpInfix = {
    "+" => ast::OpInfix::Add,
    "-" => ast::OpInfix::Subtract,
}

ExprFactor = ExprInfix<ExprFactor, OpFactor, ExprPrefix>;
OpFactor: ast::OpInfix = {
    "*" => ast::OpInfix::Multiply,
    "/" => ast::OpInfix::Divide,
    "%" => ast::OpInfix::Modulus,
}

ExprInfix<Lt, Op, Rt>: ast::Expr = {
    <lt:Spanned<Lt>> <op:Op> <rt:Spanned<Rt>> =>
        ast::Expr::Infix(Box::new(ast::ExprInfix { <> })),
    Rt,
}

ExprPrefix: ast::Expr = {
    <op:OpPrefix> <rt:Spanned<ExprPrefix>> =>
        ast::Expr::Prefix(Box::new(ast::ExprPrefix { <> })),
    ExprSimple
}
OpPrefix: ast::OpPrefix = {
    "-" => ast::OpPrefix::Negate,
    "!" => ast::OpPrefix::Not,
}

ExprSimple: ast::Expr = {
    ExprTuple,
    ExprList,
    ExprPrimary,
}

ExprTuple: ast::Expr = {
    "(" <items:SeperatedTrailing<Spanned<ExprLogicOr>, ",">> ")" => 
        ast::Expr::Tuple(ast::ExprTuple {<>}),
}
ExprList: ast::Expr = {
    "[" <items:Seperated<Spanned<ExprLogicOr>, ",">> "]" =>
        ast::Expr::List(ast::ExprList {<>}),
    }

ExprPrimary: ast::Expr = {
    // Literals
    string => ast::Expr::Literal(ast::ExprLiteral::String(<>)),
    number => ast::Expr::Literal(ast::ExprLiteral::Number(<>)),

    // Keywords
    "true" => ast::Expr::Literal(ast::ExprLiteral::Bool(true)),
    "false" => ast::Expr::Literal(ast::ExprLiteral::Bool(false)),

    // Variables
    ExprIdentifier,

    // Unit
    ExprUnit,
    
    // Blocks
    ExprBlock,

    // Grouping
    "(" <Expr> ")",

}

ExprIdentifier: ast::Expr = <name:identifier> =>
    ast::Expr::Identifier(ast::ExprIdentifier {
        identifier: ast::Identifier {
            name
        }
    });

ExprUnit: ast::Expr = "(" ")" =>
    ast::Expr::Unit;

ExprBlock: ast::Expr = "{" <stmts:(<StmtS>)*> <return_expr:(ExprS)?> "}" =>
    ast::Expr::Block(Box::new(
        ast::ExprBlock {
            stmts,
            return_expr
        }
    ));

/// Utilities

Spanned<T>: span::Spanned<T> = <l:@L> <t:T> <r:@R> =>
    (t, l..r);

Seperated<E, T>: Vec<ast::ExprS> = {
    <first:E> <mut args:(T <E>)*> => {
        args.insert(0, first);
        args
    },
    () => Vec::new(),
}

SeperatedTrailing<E, T>: Vec<ast::ExprS> =
    <first:E> <mut args:(T <E>)*> <trailing_seperator:T> => {
        args.insert(0, first);
        args
    };

extern {
    type Location = usize;
    type Error = ErrorS;

    enum lexer::Token {
        // Single-character tokens.
        "{" => lexer::Token::BraceOpen,
        "}" => lexer::Token::BraceClose,
        "[" => lexer::Token::BracketOpen,
        "]" => lexer::Token::BracketClose,
        "(" => lexer::Token::ParanOpen,
        ")" => lexer::Token::ParanClose,
        ";" => lexer::Token::Semicolon,
        "," => lexer::Token::Comma,

        "-" => lexer::Token::Minus,
        "+" => lexer::Token::Plus,
        "/" => lexer::Token::Slash,
        "%" => lexer::Token::Modulus,
        "*" => lexer::Token::Asterisk,

        "!" => lexer::Token::Bang,
        "!=" => lexer::Token::BangEqual,
        "=" => lexer::Token::Equal,
        "==" => lexer::Token::EqualEqual,
        ">" => lexer::Token::Greater,
        ">=" => lexer::Token::GreaterEqual,
        "<" => lexer::Token::Less,
        "<=" => lexer::Token::LessEqual,

        // Keywords
        "true" => lexer::Token::True,
        "false" => lexer::Token::False,
        "and" => lexer::Token::And,
        "or" => lexer::Token::Or,
        "if" => lexer::Token::If,
        "else" => lexer::Token::Else,

        // Literals.
        identifier => lexer::Token::Identifier(<String>),
        string => lexer::Token::String(<String>),
        number => lexer::Token::Number(<f64>),
    }
}

use lalrpop_util::ParseError;
use crate::errors::ErrorS;

use crate::{ast, lexer, span};

grammar<'err>(
    errors: &'err mut Vec<ParseError<usize, lexer::Token, ErrorS>>
);

pub Module: ast::Module = <stmts:Spanned<Stmt>*> => ast::Module { <> };

StmtS = Spanned<Stmt>;

// Statements
Stmt: ast::Stmt = {
    StmtExpr,
    <e:!> => {
        errors.push(e.error);
        ast::Stmt::Error
    },
}

StmtExpr: ast::Stmt = <value:ExprS> ";" =>
    ast::Stmt::Expr(ast::StmtExpr { <> });

// Expressions
ExprS = Spanned<Expr>;

Expr = {
    ExprBlock,
    ExprPrimary,
    ExprList,
    ExprTuple,
    ExprUnit,
};

ExprUnit: ast::Expr = "(" ")" => ast::Expr::Unit;

ExprTuple: ast::Expr = "(" <items:SeperatedTrailing<",">> ")" => ast::Expr::Tuple(ast::ExprTuple {<>});

ExprList: ast::Expr = "[" <items:Seperated<",">> "]" => ast::Expr::List(ast::ExprList {<>});

ExprBlock: ast::Expr = "{" <stmts:(<StmtS>)*> <return_expr:(ExprS)?> "}" =>
    ast::Expr::Block(Box::new(
        ast::ExprBlock {
            stmts,
            return_expr
        }
    ));

ExprPrimary: ast::Expr = {
    // Literals
    string => ast::Expr::Literal(ast::ExprLiteral::String(<>)),
    number => ast::Expr::Literal(ast::ExprLiteral::Number(<>)),

    // Keywords
    "true" => ast::Expr::Literal(ast::ExprLiteral::Bool(true)),
    "false" => ast::Expr::Literal(ast::ExprLiteral::Bool(false)),

    // Variables
    ExprIdentifier,

    // Grouping
    "(" <Expr> ")",
}

ExprIdentifier: ast::Expr = <name:identifier> =>
    ast::Expr::Identifier(ast::ExprIdentifier {
        identifier: ast::Identifier {
            name
        }
    });

/// Utilities

Spanned<T>: span::Spanned<T> = <l:@L> <t:T> <r:@R> => (t, l..r);

Seperated<T>: Vec<ast::ExprS> = {
    <first:ExprS> <mut args:(T <ExprS>)*> => {
        args.insert(0, first);
        args
    },
    () => Vec::new(),
}

SeperatedTrailing<T>: Vec<ast::ExprS> =
    <first:ExprS> <mut args:(T <ExprS>)*> <trailing_seperator:T> => {
        args.insert(0, first);
        args
    };

extern {
    type Location = usize;
    type Error = ErrorS;

    enum lexer::Token {
        // Single-character tokens.
        "{" => lexer::Token::BraceOpen,
        "}" => lexer::Token::BraceClose,
        "[" => lexer::Token::BracketOpen,
        "]" => lexer::Token::BracketClose,
        "(" => lexer::Token::ParanOpen,
        ")" => lexer::Token::ParanClose,
        ";" => lexer::Token::Semicolon,
        "," => lexer::Token::Comma,

        // Keywords
        "true" => lexer::Token::True,
        "false" => lexer::Token::False,

        // Literals.
        identifier => lexer::Token::Identifier(<String>),
        string => lexer::Token::String(<String>),
        number => lexer::Token::Number(<f64>),
    }
}

use lalrpop_util::ParseError;
use crate::errors::ErrorS;

use crate::{ast, lexer, span};

grammar<'err>(
    errors: &'err mut Vec<ParseError<usize, lexer::Token, ErrorS>>
);

pub Module: ast::Module = <stmts:Spanned<Decl>*> => ast::Module { <> };

Decl = {
    DeclLetVar,
    Stmt,
}

DeclLetVar: ast::Stmt = <assign:StmtAssign> =>
    ast::Stmt::Assign(<>);

StmtAssign: ast::StmtAssign = {
    "let" <name:identifier> <type_identifier:(":" <identifier>)?> <value:("=" <ExprS>)?> ";" => ast::StmtAssign {
        identifier: ast::Identifier {
            name,
        },
        type_identifier: type_identifier.map(|name| ast::Identifier { name }),
        is_const: false,
        value,
    },
    "const" <name:identifier> <type_identifier:(":" <identifier>)?> <value:("=" <ExprS>)?> ";" => ast::StmtAssign {
        identifier: ast::Identifier {
            name,
        },
        type_identifier: type_identifier.map(|name| ast::Identifier { name }),
        is_const: true,
        value,
    },
}

StmtS = Spanned<Stmt>;

// Statements
Stmt: ast::Stmt = {
    <expr:ExprS> ";" =>
        ast::Stmt::Expr(ast::StmtExpr { <> }),
    <e:!> => {
        errors.push(e.error);
        ast::Stmt::Error
    },
}

// Expressions
ExprS = Spanned<Expr>;

Expr: ast::Expr = {
    ExprAssign,
    ExprBlock
};

ExprAssign: ast::Expr = {
    <name:identifier> "=" <value:ExprS> =>
        ast::Expr::Assign(Box::new(ast::ExprAssign {
            identifier: ast::Identifier { name },
            value,
        })),
    ExprIf,
}

ExprIf: ast::Expr = {
    // if .. else ..
    "if" "(" <cond:Spanned<ExprLogicOr>> ")" <then:Spanned<ExprBlock>> 
    <else_:("else" <Spanned<ExprBlock>>)?>
    => {
        ast::Expr::If(Box::new(ast::ExprIf { <> }))
    },

    // if .. else if ..
    "if" "(" <cond:Spanned<ExprLogicOr>> ")" <then:Spanned<ExprBlock>> 
    <else_:("else" <Spanned<ExprIf>>)>
    => {
        ast::Expr::If(Box::new(ast::ExprIf { 
            cond,
            then,
            else_: Some(else_)
         }))
    },
    ExprLogicOr
}

ExprLogicOr = ExprInfix<ExprLogicOr, OpLogicOr, ExprLogicAnd>;
OpLogicOr: ast::OpInfix = "or" => ast::OpInfix::LogicOr;

ExprLogicAnd = ExprInfix<ExprLogicAnd, OpLogicAnd, ExprEquality>;
OpLogicAnd: ast::OpInfix = "and" => ast::OpInfix::LogicAnd;

ExprEquality = ExprInfix<ExprEquality, OpEquality, ExprComparison>;
OpEquality: ast::OpInfix = {
    "==" => ast::OpInfix::Equal,
    "!=" => ast::OpInfix::NotEqual,
}

ExprComparison = ExprInfix<ExprComparison, OpComparison, ExprTerm>;
OpComparison: ast::OpInfix = {
    ">" => ast::OpInfix::Greater,
    ">=" => ast::OpInfix::GreaterEqual,
    "<" => ast::OpInfix::Less,
    "<=" => ast::OpInfix::LessEqual,
}

ExprTerm = ExprInfix<ExprTerm, OpTerm, ExprFactor>;
OpTerm: ast::OpInfix = {
    "+" => ast::OpInfix::Add,
    "-" => ast::OpInfix::Subtract,
}

ExprFactor = ExprInfix<ExprFactor, OpFactor, ExprPrefix>;
OpFactor: ast::OpInfix = {
    "*" => ast::OpInfix::Multiply,
    "/" => ast::OpInfix::Divide,
    "%" => ast::OpInfix::Modulus,
}

ExprInfix<Lt, Op, Rt>: ast::Expr = {
    <lt:Spanned<Lt>> <op:Op> <rt:Spanned<Rt>> =>
        ast::Expr::Infix(Box::new(ast::ExprInfix { <> })),
    Rt,
}

ExprPrefix: ast::Expr = {
    <op:OpPrefix> <rt:Spanned<ExprPrefix>> =>
        ast::Expr::Prefix(Box::new(ast::ExprPrefix { <> })),
    ExprSimple
}
OpPrefix: ast::OpPrefix = {
    "-" => ast::OpPrefix::Negate,
    "!" => ast::OpPrefix::Not,
}

ExprSimple: ast::Expr = {
    ExprList
};

ExprList: ast::Expr = {
    "[" <items:Seperated<Spanned<Expr>, ",">> "]" =>
        ast::Expr::List(ast::ExprList {<>}),
        ExprTuple
}

ExprTuple: ast::Expr = {
    "(" <items:SeperatedTrailing<Spanned<Expr>, ",">> ")" => 
        ast::Expr::Tuple(ast::ExprTuple {<>}),
        ExprPrimary,
}

ExprPrimary: ast::Expr = {
    // Literals
    string => ast::Expr::Literal(ast::ExprLiteral::String(<>)),
    number => ast::Expr::Literal(ast::ExprLiteral::Number(<>)),
    "void" => ast::Expr::Unit,
    "true" => ast::Expr::Literal(ast::ExprLiteral::Bool(true)),
    "false" => ast::Expr::Literal(ast::ExprLiteral::Bool(false)),

    // Variables
    ExprIdentifier,

    ExprRange,

    // Grouping
    "(" <Expr> ")",

}

ExprIdentifier: ast::Expr = <name:identifier> =>
    ast::Expr::Identifier(ast::ExprIdentifier {
        identifier: ast::Identifier {
            name
        }
    });

ExprRange: ast::Expr = <start:Spanned<number>?> ".." <inclusive_end:"="?> <end:Spanned<number>?> =>
    ast::Expr::Range(ast::ExprRange {
        start: start.map(|start| (ast::ExprLiteral::Number(start.0), start.1)),
        end: end.map(|end| (ast::ExprLiteral::Number(end.0), end.1)),
        inclusive_end: inclusive_end.is_some()
    });

ExprBlock: ast::Expr = {
    "{" <stmts:(<Spanned<Decl>>)*> <return_expr:(ExprS)?> "}" =>
    ast::Expr::Block(Box::new(
        ast::ExprBlock {
            stmts,
            return_expr
        }
    )),
}

/// Utilities

Spanned<T>: span::Spanned<T> = <l:@L> <t:T> <r:@R> =>
    (t, l..r);

SeperatedNoDefault<E, T>: Vec<ast::ExprS> = {
    <first:E> <mut args:(T <E>)+> => {
        args.insert(0, first);
        args
    },
}

Seperated<E, T>: Vec<ast::ExprS> = {
    <first:E> <mut args:(T <E>)*> => {
        args.insert(0, first);
        args
    },
    () => Vec::new(),
}

SeperatedTrailing<E, T>: Vec<ast::ExprS> =
    <first:E> <mut args:(T <E>)*> <trailing_seperator:T> => {
        args.insert(0, first);
        args
    };

extern {
    type Location = usize;
    type Error = ErrorS;

    enum lexer::Token {
        "{" => lexer::Token::BraceOpen,
        "}" => lexer::Token::BraceClose,
        "[" => lexer::Token::BracketOpen,
        "]" => lexer::Token::BracketClose,
        "(" => lexer::Token::ParanOpen,
        ")" => lexer::Token::ParanClose,
        ";" => lexer::Token::Semicolon,
        "," => lexer::Token::Comma,
        "=>" => lexer::Token::FatArrow,
        ".." => lexer::Token::DotDot,
        ":" => lexer::Token::Colon,

        "-" => lexer::Token::Minus,
        "+" => lexer::Token::Plus,
        "/" => lexer::Token::Slash,
        "%" => lexer::Token::Modulus,
        "*" => lexer::Token::Asterisk,

        "!" => lexer::Token::Bang,
        "!=" => lexer::Token::BangEqual,
        "=" => lexer::Token::Equal,
        "==" => lexer::Token::EqualEqual,
        ">" => lexer::Token::Greater,
        ">=" => lexer::Token::GreaterEqual,
        "<" => lexer::Token::Less,
        "<=" => lexer::Token::LessEqual,

        // Keywords
        "true" => lexer::Token::True,
        "false" => lexer::Token::False,
        "and" => lexer::Token::And,
        "or" => lexer::Token::Or,
        "if" => lexer::Token::If,
        "else" => lexer::Token::Else,
        "fn" => lexer::Token::Fn,
        "void" => lexer::Token::Void,
        "let" => lexer::Token::Let,
        "const" => lexer::Token::Const,

        // Literals.
        identifier => lexer::Token::Identifier(<String>),
        string => lexer::Token::String(<String>),
        number => lexer::Token::Number(<f64>),
    }
}

use lalrpop_util::ParseError;
use egonlang_errors::EgonErrorS;

use crate::{ast, lexer};
use span;
use egonlang_types::Type;

grammar<'err>(
    errors: &'err mut Vec<ParseError<usize, lexer::Token, EgonErrorS>>
);

pub Module: ast::Module = <stmts:StmtS*> => ast::Module { <> };

// Statements
StmtS = Spanned<Stmt>;

Stmt: ast::Stmt = {
    StmtExpr,
    StmtAssertType,
    StmtReturn,
    StmtAssignVariable,
    StmtAssignConst,
    StmtTypeAlias,
    StmtFn,
    <e:!> => {
        errors.push(e.error);
        ast::Stmt::Error
    },
};

StmtExpr: ast::Stmt = <expr:ExprS> ";" =>
        ast::Stmt::Expr(ast::StmtExpr { <> });

StmtAssertType: ast::Stmt = "assert_type" <value:ExprS> "," <expected_type:Spanned<Type>> ";" =>
        ast::Stmt::AssertType(ast::StmtAssertType { 
            value,
            expected_type: (ast::Expr::Type(ast::ExprType(expected_type.0)), expected_type.1)
        });

StmtReturn: ast::Stmt = "return" <value:ExprS> ";" =>
        ast::Stmt::Return(ast::StmtReturn::new(<>));

StmtAssignVariable: ast::Stmt = "let" <identifier:Spanned<Identifier>> <type_expr:(":" <Spanned<Type>>)?> <value:("=" <ExprS>)?> ";" =>
        ast::StmtAssign {
            identifier,
            type_expr: type_expr.map(|(ty, ty_span)|
                (ast::Expr::Type(ast::ExprType(ty)), ty_span)),
            is_const: false,
            value,
        }.into();

StmtAssignConst: ast::Stmt = "const" <identifier:Spanned<Identifier>> <type_expr:(":" <Spanned<Type>>)?> <value:("=" <ExprS>)?> ";" =>
        ast::StmtAssign {
            identifier,
            type_expr: type_expr.map(|(ty, ty_span)|
                (ast::Expr::Type(ast::ExprType(ty)), ty_span)),
            is_const: true,
            value,
        }.into();

StmtTypeAlias: ast::Stmt = "type" <alias:Spanned<Identifier>> <value:("=" <Spanned<Type>>)> ";" =>
        ast::StmtTypeAlias { <> }.into();

StmtFn: ast::Stmt = "fn" <name:Spanned<Identifier>> <fn_expr:Spanned<ExprFn>> =>
    ast::Stmt::Fn(Box::new(ast::StmtFn { 
        name,
        fn_expr
    }));

// Expressions
ExprS = Spanned<Expr>;

Expr: ast::Expr = {
    ExprAssign,
    ExprBlock,
    
};

ExprAssign: ast::Expr = {
    <identifier:Spanned<Identifier>> "=" <value:ExprS> =>
        ast::Expr::Assign(Box::new(ast::ExprAssign { <> })),
    ExprIf,
}

ExprIf: ast::Expr = {
    // if .. else ..
    // The condition expression is `ExprLogicOr` to limit expression types allowed
    // 
    // Not Allowed:
    // - Assignment Expressions
    // - If Expressions
    "if" <cond:Spanned<ExprLogicOr>> <then:Spanned<ExprBlock>> 
    <else_:("else" <Spanned<ExprBlock>>)?>
    => {
        ast::Expr::If(Box::new(ast::ExprIf { <> }))
    },

    // if .. else if ..
    "if" <cond:Spanned<ExprLogicOr>> <then:Spanned<ExprBlock>> 
    <else_:("else" <Spanned<ExprIf>>)>
    => {
        ast::Expr::If(Box::new(ast::ExprIf { 
            cond,
            then,
            else_: Some(else_)
         }))
    },
    ExprLogicOr
}

// The following make up the majority of expression types
//
// They are chained together like this to implement syntax 

ExprLogicOr = ExprInfix<ExprLogicOr, OpLogicOr, ExprLogicAnd>;
OpLogicOr: ast::OpInfix = "or" => ast::OpInfix::LogicOr;

ExprLogicAnd = ExprInfix<ExprLogicAnd, OpLogicAnd, ExprEquality>;
OpLogicAnd: ast::OpInfix = "and" => ast::OpInfix::LogicAnd;

ExprEquality = ExprInfix<ExprEquality, OpEquality, ExprComparison>;
OpEquality: ast::OpInfix = {
    "==" => ast::OpInfix::Equal,
    "!=" => ast::OpInfix::NotEqual,
}

ExprComparison = ExprInfix<ExprComparison, OpComparison, ExprTerm>;
OpComparison: ast::OpInfix = {
    ">" => ast::OpInfix::Greater,
    ">=" => ast::OpInfix::GreaterEqual,
    "<" => ast::OpInfix::Less,
    "<=" => ast::OpInfix::LessEqual,
}

ExprTerm = ExprInfix<ExprTerm, OpTerm, ExprFactor>;
OpTerm: ast::OpInfix = {
    "+" => ast::OpInfix::Add,
    "-" => ast::OpInfix::Subtract,
}

ExprFactor = ExprInfix<ExprFactor, OpFactor, ExprPrefix>;
OpFactor: ast::OpInfix = {
    "*" => ast::OpInfix::Multiply,
    "/" => ast::OpInfix::Divide,
    "%" => ast::OpInfix::Modulus,
}

ExprInfix<Lt, Op, Rt>: ast::Expr = {
    <lt:Spanned<Lt>> <op:Op> <rt:Spanned<Rt>> =>
        ast::Expr::Infix(Box::new(ast::ExprInfix { <> })),
    Rt,
}

ExprPrefix: ast::Expr = {
    <op:OpPrefix> <rt:Spanned<ExprPrefix>> =>
        ast::Expr::Prefix(Box::new(ast::ExprPrefix { <> })),
    ExprSimple
}
OpPrefix: ast::OpPrefix = {
    "-" => ast::OpPrefix::Negate,
    "!" => ast::OpPrefix::Not,
}

ExprSimple: ast::Expr = {
    ExprList,
    
};

ExprList: ast::Expr = {
    "[" <items:Seperated<Spanned<Expr>, ",">> "]" =>
        ast::Expr::List(Box::new(ast::ExprList {<>})),
        ExprTuple
}

ExprTuple: ast::Expr = {
    "(" <items:SeperatedTrailing<Spanned<Expr>, ",">> ")" => 
        ast::Expr::Tuple(Box::new(ast::ExprTuple {<>})),
        ExprPrimary,
}

ExprPrimary: ast::Expr = {
    // Literals
    string => ast::Expr::Literal(ast::ExprLiteral::String(<>)),
    number => ast::Expr::Literal(ast::ExprLiteral::Number(<>)),
    "(" ")" => ast::Expr::Unit,
    "true" => ast::Expr::Literal(ast::ExprLiteral::Bool(true)),
    "false" => ast::Expr::Literal(ast::ExprLiteral::Bool(false)),

    // Variables
    ExprIdentifier,

    ExprRange,

    ExprFn,

    // Grouping
    "(" <Expr> ")",

}

Identifier: ast::Identifier = <name:identifier> =>
    ast::Identifier {
        name
    };

ExprIdentifier: ast::Expr = <name:identifier> =>
    ast::Expr::Identifier(ast::ExprIdentifier {
        identifier: ast::Identifier {
            name
        }
    });

#[inline]
ExprRange: ast::Expr = {
    <start:Spanned<number>> ".." <inclusive_end:"="?> <end:Spanned<number>> =>
        ast::Expr::Range(ast::ExprRange {
            start: Some((ast::ExprLiteral::Number(start.0), start.1)),
            end: Some((ast::ExprLiteral::Number(end.0), end.1)),
            inclusive_end: inclusive_end.is_some()
        }),
    <start:Spanned<number>> ".." =>
        ast::Expr::Range(ast::ExprRange {
            start: Some((ast::ExprLiteral::Number(start.0), start.1)),
            end: None,
            inclusive_end: false
        }),
    ".." <inclusive_end:"="?> <end:Spanned<number>> =>
        ast::Expr::Range(ast::ExprRange {
            start: None,
            end: Some((ast::ExprLiteral::Number(end.0), end.1)),
            inclusive_end: inclusive_end.is_some()
        }),
}

ExprBlock: ast::Expr = {
    "{" <stmts:(<StmtS>)*> <return_expr:(ExprS)?> "}" =>
    ast::Expr::Block(Box::new(
        ast::ExprBlock {
            stmts,
            return_expr,
            typeref: None
        }
    )),
}

FnParam: (ast::Identifier, Type) = <name:identifier> ":" <typeref:Type> => (ast::Identifier { name }, typeref);

ExprFn: ast::Expr = {
   "(" <params:Seperated<Spanned<FnParam>, ",">> ")" ":" <return_type:Spanned<Type>> "=>" <body:Spanned<ExprBlock>> =>
        ast::Expr::Fn(Box::new(ast::ExprFn { 
            name: None,
            params,
            return_type,
            body,
         })),
    "(" <params:Seperated<Spanned<FnParam>, ",">> ")" ":" <return_type:Spanned<Type>> "=>" <body:Spanned<ExprFn>> =>
        ast::Expr::Fn(Box::new(ast::ExprFn { 
            name: None,
            params,
            return_type,
            body,
         })),
}

/// Utilities

Type: Type = {
    <base:identifier> <args:("<" <Seperated<Type, ",">> ">")?> => {
        Type(base, args.unwrap_or_default())
    },

    "(" ")" => Type::unit()
}

Spanned<T>: span::Spanned<T> = <l:@L> <t:T> <r:@R> =>
    (t, l..r);

SeperatedNoDefault<E, T>: Vec<ast::ExprS> = {
    <first:E> <mut args:(T <E>)+> => {
        args.insert(0, first);
        args
    },
}

#[inline]
Seperated<E, T>: Vec<E> = {
    <first:E> <mut args:(T <E>)*> => {
        args.insert(0, first);
        args
    },
    () => Vec::new(),
}

SeperatedTrailing<E, T>: Vec<ast::ExprS> =
    <first:E> <mut args:(T <E>)*> <trailing_seperator:T> => {
        args.insert(0, first);
        args
    };

extern {
    type Location = usize;
    type Error = EgonErrorS;

    enum lexer::Token {
        "{" => lexer::Token::BraceOpen,
        "}" => lexer::Token::BraceClose,
        "[" => lexer::Token::BracketOpen,
        "]" => lexer::Token::BracketClose,
        "(" => lexer::Token::ParanOpen,
        ")" => lexer::Token::ParanClose,
        ";" => lexer::Token::Semicolon,
        "," => lexer::Token::Comma,
        "=>" => lexer::Token::FatArrow,
        ".." => lexer::Token::DotDot,
        ":" => lexer::Token::Colon,

        "-" => lexer::Token::Minus,
        "+" => lexer::Token::Plus,
        "/" => lexer::Token::Slash,
        "%" => lexer::Token::Modulus,
        "*" => lexer::Token::Asterisk,

        "!" => lexer::Token::Bang,
        "!=" => lexer::Token::BangEqual,
        "=" => lexer::Token::Equal,
        "==" => lexer::Token::EqualEqual,
        ">" => lexer::Token::Greater,
        ">=" => lexer::Token::GreaterEqual,
        "<" => lexer::Token::Less,
        "<=" => lexer::Token::LessEqual,

        // Keywords
        "true" => lexer::Token::True,
        "false" => lexer::Token::False,
        "and" => lexer::Token::And,
        "or" => lexer::Token::Or,
        "if" => lexer::Token::If,
        "else" => lexer::Token::Else,
        "fn" => lexer::Token::Fn,
        "let" => lexer::Token::Let,
        "const" => lexer::Token::Const,
        "type" => lexer::Token::Type,
        "assert_type" => lexer::Token::AssertType,
        "return" => lexer::Token::Return,

        // Literals.
        identifier => lexer::Token::Identifier(<String>),
        string => lexer::Token::String(<String>),
        number => lexer::Token::Number(<f64>),
    }
}

